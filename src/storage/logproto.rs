// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `logproto.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct PushRequest {
    // message fields
    pub streams: ::protobuf::RepeatedField<StreamAdapter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PushRequest {
    fn default() -> &'a PushRequest {
        <PushRequest as ::protobuf::Message>::default_instance()
    }
}

impl PushRequest {
    pub fn new() -> PushRequest {
        ::std::default::Default::default()
    }

    // repeated .logproto.StreamAdapter streams = 1;


    pub fn get_streams(&self) -> &[StreamAdapter] {
        &self.streams
    }
    pub fn clear_streams(&mut self) {
        self.streams.clear();
    }

    // Param is passed by value, moved
    pub fn set_streams(&mut self, v: ::protobuf::RepeatedField<StreamAdapter>) {
        self.streams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_streams(&mut self) -> &mut ::protobuf::RepeatedField<StreamAdapter> {
        &mut self.streams
    }

    // Take field
    pub fn take_streams(&mut self) -> ::protobuf::RepeatedField<StreamAdapter> {
        ::std::mem::replace(&mut self.streams, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PushRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.streams {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.streams)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.streams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.streams {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PushRequest {
        PushRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StreamAdapter>>(
                "streams",
                |m: &PushRequest| { &m.streams },
                |m: &mut PushRequest| { &mut m.streams },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PushRequest>(
                "PushRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PushRequest {
        static instance: ::protobuf::rt::LazyV2<PushRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PushRequest::new)
    }
}

impl ::protobuf::Clear for PushRequest {
    fn clear(&mut self) {
        self.streams.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PushRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PushRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PushResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PushResponse {
    fn default() -> &'a PushResponse {
        <PushResponse as ::protobuf::Message>::default_instance()
    }
}

impl PushResponse {
    pub fn new() -> PushResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PushResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PushResponse {
        PushResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PushResponse>(
                "PushResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PushResponse {
        static instance: ::protobuf::rt::LazyV2<PushResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PushResponse::new)
    }
}

impl ::protobuf::Clear for PushResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PushResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PushResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryRequest {
    // message fields
    pub selector: ::std::string::String,
    pub limit: u32,
    pub start: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub direction: Direction,
    pub shards: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryRequest {
    fn default() -> &'a QueryRequest {
        <QueryRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryRequest {
    pub fn new() -> QueryRequest {
        ::std::default::Default::default()
    }

    // string selector = 1;


    pub fn get_selector(&self) -> &str {
        &self.selector
    }
    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: ::std::string::String) {
        self.selector = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut ::std::string::String {
        &mut self.selector
    }

    // Take field
    pub fn take_selector(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.selector, ::std::string::String::new())
    }

    // uint32 limit = 2;


    pub fn get_limit(&self) -> u32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u32) {
        self.limit = v;
    }

    // .google.protobuf.Timestamp start = 3;


    pub fn get_start(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start.is_none() {
            self.start.set_default();
        }
        self.start.as_mut().unwrap()
    }

    // Take field
    pub fn take_start(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end = 4;


    pub fn get_end(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end(&mut self) {
        self.end.clear();
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end.is_none() {
            self.end.set_default();
        }
        self.end.as_mut().unwrap()
    }

    // Take field
    pub fn take_end(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .logproto.Direction direction = 5;


    pub fn get_direction(&self) -> Direction {
        self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction = Direction::FORWARD;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: Direction) {
        self.direction = v;
    }

    // repeated string shards = 7;


    pub fn get_shards(&self) -> &[::std::string::String] {
        &self.shards
    }
    pub fn clear_shards(&mut self) {
        self.shards.clear();
    }

    // Param is passed by value, moved
    pub fn set_shards(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.shards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shards(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.shards
    }

    // Take field
    pub fn take_shards(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.shards, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.selector)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.limit = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 5, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.shards)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.selector.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.selector);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.direction != Direction::FORWARD {
            my_size += ::protobuf::rt::enum_size(5, self.direction);
        }
        for value in &self.shards {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.selector.is_empty() {
            os.write_string(1, &self.selector)?;
        }
        if self.limit != 0 {
            os.write_uint32(2, self.limit)?;
        }
        if let Some(ref v) = self.start.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.direction != Direction::FORWARD {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.direction))?;
        }
        for v in &self.shards {
            os.write_string(7, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRequest {
        QueryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "selector",
                |m: &QueryRequest| { &m.selector },
                |m: &mut QueryRequest| { &mut m.selector },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "limit",
                |m: &QueryRequest| { &m.limit },
                |m: &mut QueryRequest| { &mut m.limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "start",
                |m: &QueryRequest| { &m.start },
                |m: &mut QueryRequest| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "end",
                |m: &QueryRequest| { &m.end },
                |m: &mut QueryRequest| { &mut m.end },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Direction>>(
                "direction",
                |m: &QueryRequest| { &m.direction },
                |m: &mut QueryRequest| { &mut m.direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shards",
                |m: &QueryRequest| { &m.shards },
                |m: &mut QueryRequest| { &mut m.shards },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryRequest>(
                "QueryRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryRequest {
        static instance: ::protobuf::rt::LazyV2<QueryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryRequest::new)
    }
}

impl ::protobuf::Clear for QueryRequest {
    fn clear(&mut self) {
        self.selector.clear();
        self.limit = 0;
        self.start.clear();
        self.end.clear();
        self.direction = Direction::FORWARD;
        self.shards.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SampleQueryRequest {
    // message fields
    pub selector: ::std::string::String,
    pub start: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub shards: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SampleQueryRequest {
    fn default() -> &'a SampleQueryRequest {
        <SampleQueryRequest as ::protobuf::Message>::default_instance()
    }
}

impl SampleQueryRequest {
    pub fn new() -> SampleQueryRequest {
        ::std::default::Default::default()
    }

    // string selector = 1;


    pub fn get_selector(&self) -> &str {
        &self.selector
    }
    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: ::std::string::String) {
        self.selector = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut ::std::string::String {
        &mut self.selector
    }

    // Take field
    pub fn take_selector(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.selector, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp start = 2;


    pub fn get_start(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start.is_none() {
            self.start.set_default();
        }
        self.start.as_mut().unwrap()
    }

    // Take field
    pub fn take_start(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end = 3;


    pub fn get_end(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end(&mut self) {
        self.end.clear();
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end.is_none() {
            self.end.set_default();
        }
        self.end.as_mut().unwrap()
    }

    // Take field
    pub fn take_end(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // repeated string shards = 4;


    pub fn get_shards(&self) -> &[::std::string::String] {
        &self.shards
    }
    pub fn clear_shards(&mut self) {
        self.shards.clear();
    }

    // Param is passed by value, moved
    pub fn set_shards(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.shards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shards(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.shards
    }

    // Take field
    pub fn take_shards(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.shards, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SampleQueryRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.selector)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.shards)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.selector.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.selector);
        }
        if let Some(ref v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.shards {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.selector.is_empty() {
            os.write_string(1, &self.selector)?;
        }
        if let Some(ref v) = self.start.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.shards {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SampleQueryRequest {
        SampleQueryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "selector",
                |m: &SampleQueryRequest| { &m.selector },
                |m: &mut SampleQueryRequest| { &mut m.selector },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "start",
                |m: &SampleQueryRequest| { &m.start },
                |m: &mut SampleQueryRequest| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "end",
                |m: &SampleQueryRequest| { &m.end },
                |m: &mut SampleQueryRequest| { &mut m.end },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shards",
                |m: &SampleQueryRequest| { &m.shards },
                |m: &mut SampleQueryRequest| { &mut m.shards },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SampleQueryRequest>(
                "SampleQueryRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SampleQueryRequest {
        static instance: ::protobuf::rt::LazyV2<SampleQueryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SampleQueryRequest::new)
    }
}

impl ::protobuf::Clear for SampleQueryRequest {
    fn clear(&mut self) {
        self.selector.clear();
        self.start.clear();
        self.end.clear();
        self.shards.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SampleQueryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SampleQueryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SampleQueryResponse {
    // message fields
    pub series: ::protobuf::RepeatedField<Series>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SampleQueryResponse {
    fn default() -> &'a SampleQueryResponse {
        <SampleQueryResponse as ::protobuf::Message>::default_instance()
    }
}

impl SampleQueryResponse {
    pub fn new() -> SampleQueryResponse {
        ::std::default::Default::default()
    }

    // repeated .logproto.Series series = 1;


    pub fn get_series(&self) -> &[Series] {
        &self.series
    }
    pub fn clear_series(&mut self) {
        self.series.clear();
    }

    // Param is passed by value, moved
    pub fn set_series(&mut self, v: ::protobuf::RepeatedField<Series>) {
        self.series = v;
    }

    // Mutable pointer to the field.
    pub fn mut_series(&mut self) -> &mut ::protobuf::RepeatedField<Series> {
        &mut self.series
    }

    // Take field
    pub fn take_series(&mut self) -> ::protobuf::RepeatedField<Series> {
        ::std::mem::replace(&mut self.series, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SampleQueryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.series {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.series)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.series {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.series {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SampleQueryResponse {
        SampleQueryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Series>>(
                "series",
                |m: &SampleQueryResponse| { &m.series },
                |m: &mut SampleQueryResponse| { &mut m.series },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SampleQueryResponse>(
                "SampleQueryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SampleQueryResponse {
        static instance: ::protobuf::rt::LazyV2<SampleQueryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SampleQueryResponse::new)
    }
}

impl ::protobuf::Clear for SampleQueryResponse {
    fn clear(&mut self) {
        self.series.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SampleQueryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SampleQueryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryResponse {
    // message fields
    pub streams: ::protobuf::RepeatedField<StreamAdapter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryResponse {
    fn default() -> &'a QueryResponse {
        <QueryResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryResponse {
    pub fn new() -> QueryResponse {
        ::std::default::Default::default()
    }

    // repeated .logproto.StreamAdapter streams = 1;


    pub fn get_streams(&self) -> &[StreamAdapter] {
        &self.streams
    }
    pub fn clear_streams(&mut self) {
        self.streams.clear();
    }

    // Param is passed by value, moved
    pub fn set_streams(&mut self, v: ::protobuf::RepeatedField<StreamAdapter>) {
        self.streams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_streams(&mut self) -> &mut ::protobuf::RepeatedField<StreamAdapter> {
        &mut self.streams
    }

    // Take field
    pub fn take_streams(&mut self) -> ::protobuf::RepeatedField<StreamAdapter> {
        ::std::mem::replace(&mut self.streams, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.streams {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.streams)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.streams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.streams {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryResponse {
        QueryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StreamAdapter>>(
                "streams",
                |m: &QueryResponse| { &m.streams },
                |m: &mut QueryResponse| { &mut m.streams },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryResponse>(
                "QueryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryResponse {
        static instance: ::protobuf::rt::LazyV2<QueryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryResponse::new)
    }
}

impl ::protobuf::Clear for QueryResponse {
    fn clear(&mut self) {
        self.streams.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LabelRequest {
    // message fields
    pub name: ::std::string::String,
    pub values: bool,
    pub start: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LabelRequest {
    fn default() -> &'a LabelRequest {
        <LabelRequest as ::protobuf::Message>::default_instance()
    }
}

impl LabelRequest {
    pub fn new() -> LabelRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // bool values = 2;


    pub fn get_values(&self) -> bool {
        self.values
    }
    pub fn clear_values(&mut self) {
        self.values = false;
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: bool) {
        self.values = v;
    }

    // .google.protobuf.Timestamp start = 3;


    pub fn get_start(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start.is_none() {
            self.start.set_default();
        }
        self.start.as_mut().unwrap()
    }

    // Take field
    pub fn take_start(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end = 4;


    pub fn get_end(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end(&mut self) {
        self.end.clear();
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end.is_none() {
            self.end.set_default();
        }
        self.end.as_mut().unwrap()
    }

    // Take field
    pub fn take_end(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for LabelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.values = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.values != false {
            my_size += 2;
        }
        if let Some(ref v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.values != false {
            os.write_bool(2, self.values)?;
        }
        if let Some(ref v) = self.start.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LabelRequest {
        LabelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &LabelRequest| { &m.name },
                |m: &mut LabelRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "values",
                |m: &LabelRequest| { &m.values },
                |m: &mut LabelRequest| { &mut m.values },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "start",
                |m: &LabelRequest| { &m.start },
                |m: &mut LabelRequest| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "end",
                |m: &LabelRequest| { &m.end },
                |m: &mut LabelRequest| { &mut m.end },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LabelRequest>(
                "LabelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LabelRequest {
        static instance: ::protobuf::rt::LazyV2<LabelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LabelRequest::new)
    }
}

impl ::protobuf::Clear for LabelRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.values = false;
        self.start.clear();
        self.end.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LabelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LabelResponse {
    // message fields
    pub values: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LabelResponse {
    fn default() -> &'a LabelResponse {
        <LabelResponse as ::protobuf::Message>::default_instance()
    }
}

impl LabelResponse {
    pub fn new() -> LabelResponse {
        ::std::default::Default::default()
    }

    // repeated string values = 1;


    pub fn get_values(&self) -> &[::std::string::String] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LabelResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.values {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.values {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LabelResponse {
        LabelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "values",
                |m: &LabelResponse| { &m.values },
                |m: &mut LabelResponse| { &mut m.values },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LabelResponse>(
                "LabelResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LabelResponse {
        static instance: ::protobuf::rt::LazyV2<LabelResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LabelResponse::new)
    }
}

impl ::protobuf::Clear for LabelResponse {
    fn clear(&mut self) {
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LabelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamAdapter {
    // message fields
    pub labels: ::std::string::String,
    pub entries: ::protobuf::RepeatedField<EntryAdapter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamAdapter {
    fn default() -> &'a StreamAdapter {
        <StreamAdapter as ::protobuf::Message>::default_instance()
    }
}

impl StreamAdapter {
    pub fn new() -> StreamAdapter {
        ::std::default::Default::default()
    }

    // string labels = 1;


    pub fn get_labels(&self) -> &str {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::string::String) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels(&mut self) -> &mut ::std::string::String {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.labels, ::std::string::String::new())
    }

    // repeated .logproto.EntryAdapter entries = 2;


    pub fn get_entries(&self) -> &[EntryAdapter] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<EntryAdapter>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<EntryAdapter> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<EntryAdapter> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamAdapter {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.labels)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.labels.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.labels);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.labels.is_empty() {
            os.write_string(1, &self.labels)?;
        }
        for v in &self.entries {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamAdapter {
        StreamAdapter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &StreamAdapter| { &m.labels },
                |m: &mut StreamAdapter| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EntryAdapter>>(
                "entries",
                |m: &StreamAdapter| { &m.entries },
                |m: &mut StreamAdapter| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamAdapter>(
                "StreamAdapter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamAdapter {
        static instance: ::protobuf::rt::LazyV2<StreamAdapter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamAdapter::new)
    }
}

impl ::protobuf::Clear for StreamAdapter {
    fn clear(&mut self) {
        self.labels.clear();
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamAdapter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamAdapter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EntryAdapter {
    // message fields
    pub timestamp: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub line: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EntryAdapter {
    fn default() -> &'a EntryAdapter {
        <EntryAdapter as ::protobuf::Message>::default_instance()
    }
}

impl EntryAdapter {
    pub fn new() -> EntryAdapter {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp timestamp = 1;


    pub fn get_timestamp(&self) -> &::protobuf::well_known_types::Timestamp {
        self.timestamp.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp.clear();
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.timestamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestamp(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.timestamp.is_none() {
            self.timestamp.set_default();
        }
        self.timestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.timestamp.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string line = 2;


    pub fn get_line(&self) -> &str {
        &self.line
    }
    pub fn clear_line(&mut self) {
        self.line.clear();
    }

    // Param is passed by value, moved
    pub fn set_line(&mut self, v: ::std::string::String) {
        self.line = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_line(&mut self) -> &mut ::std::string::String {
        &mut self.line
    }

    // Take field
    pub fn take_line(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.line, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EntryAdapter {
    fn is_initialized(&self) -> bool {
        for v in &self.timestamp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timestamp)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.line)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.line.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.line);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.timestamp.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.line.is_empty() {
            os.write_string(2, &self.line)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntryAdapter {
        EntryAdapter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "timestamp",
                |m: &EntryAdapter| { &m.timestamp },
                |m: &mut EntryAdapter| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "line",
                |m: &EntryAdapter| { &m.line },
                |m: &mut EntryAdapter| { &mut m.line },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EntryAdapter>(
                "EntryAdapter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EntryAdapter {
        static instance: ::protobuf::rt::LazyV2<EntryAdapter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EntryAdapter::new)
    }
}

impl ::protobuf::Clear for EntryAdapter {
    fn clear(&mut self) {
        self.timestamp.clear();
        self.line.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EntryAdapter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntryAdapter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Sample {
    // message fields
    pub timestamp: i64,
    pub value: f64,
    pub hash: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Sample {
    fn default() -> &'a Sample {
        <Sample as ::protobuf::Message>::default_instance()
    }
}

impl Sample {
    pub fn new() -> Sample {
        ::std::default::Default::default()
    }

    // int64 timestamp = 1;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // double value = 2;


    pub fn get_value(&self) -> f64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f64) {
        self.value = v;
    }

    // uint64 hash = 3;


    pub fn get_hash(&self) -> u64 {
        self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash = 0;
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u64) {
        self.hash = v;
    }
}

impl ::protobuf::Message for Sample {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.value = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.hash = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0. {
            my_size += 9;
        }
        if self.hash != 0 {
            my_size += ::protobuf::rt::value_size(3, self.hash, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_int64(1, self.timestamp)?;
        }
        if self.value != 0. {
            os.write_double(2, self.value)?;
        }
        if self.hash != 0 {
            os.write_uint64(3, self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Sample {
        Sample::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &Sample| { &m.timestamp },
                |m: &mut Sample| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "value",
                |m: &Sample| { &m.value },
                |m: &mut Sample| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "hash",
                |m: &Sample| { &m.hash },
                |m: &mut Sample| { &mut m.hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Sample>(
                "Sample",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Sample {
        static instance: ::protobuf::rt::LazyV2<Sample> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Sample::new)
    }
}

impl ::protobuf::Clear for Sample {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.value = 0.;
        self.hash = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Sample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sample {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Series {
    // message fields
    pub labels: ::std::string::String,
    pub samples: ::protobuf::RepeatedField<Sample>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Series {
    fn default() -> &'a Series {
        <Series as ::protobuf::Message>::default_instance()
    }
}

impl Series {
    pub fn new() -> Series {
        ::std::default::Default::default()
    }

    // string labels = 1;


    pub fn get_labels(&self) -> &str {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::string::String) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels(&mut self) -> &mut ::std::string::String {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.labels, ::std::string::String::new())
    }

    // repeated .logproto.Sample samples = 2;


    pub fn get_samples(&self) -> &[Sample] {
        &self.samples
    }
    pub fn clear_samples(&mut self) {
        self.samples.clear();
    }

    // Param is passed by value, moved
    pub fn set_samples(&mut self, v: ::protobuf::RepeatedField<Sample>) {
        self.samples = v;
    }

    // Mutable pointer to the field.
    pub fn mut_samples(&mut self) -> &mut ::protobuf::RepeatedField<Sample> {
        &mut self.samples
    }

    // Take field
    pub fn take_samples(&mut self) -> ::protobuf::RepeatedField<Sample> {
        ::std::mem::replace(&mut self.samples, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Series {
    fn is_initialized(&self) -> bool {
        for v in &self.samples {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.labels)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.samples)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.labels.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.labels);
        }
        for value in &self.samples {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.labels.is_empty() {
            os.write_string(1, &self.labels)?;
        }
        for v in &self.samples {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Series {
        Series::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &Series| { &m.labels },
                |m: &mut Series| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Sample>>(
                "samples",
                |m: &Series| { &m.samples },
                |m: &mut Series| { &mut m.samples },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Series>(
                "Series",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Series {
        static instance: ::protobuf::rt::LazyV2<Series> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Series::new)
    }
}

impl ::protobuf::Clear for Series {
    fn clear(&mut self) {
        self.labels.clear();
        self.samples.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Series {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Series {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TailRequest {
    // message fields
    pub query: ::std::string::String,
    pub delayFor: u32,
    pub limit: u32,
    pub start: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TailRequest {
    fn default() -> &'a TailRequest {
        <TailRequest as ::protobuf::Message>::default_instance()
    }
}

impl TailRequest {
    pub fn new() -> TailRequest {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    // uint32 delayFor = 3;


    pub fn get_delayFor(&self) -> u32 {
        self.delayFor
    }
    pub fn clear_delayFor(&mut self) {
        self.delayFor = 0;
    }

    // Param is passed by value, moved
    pub fn set_delayFor(&mut self, v: u32) {
        self.delayFor = v;
    }

    // uint32 limit = 4;


    pub fn get_limit(&self) -> u32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u32) {
        self.limit = v;
    }

    // .google.protobuf.Timestamp start = 5;


    pub fn get_start(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start.is_none() {
            self.start.set_default();
        }
        self.start.as_mut().unwrap()
    }

    // Take field
    pub fn take_start(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for TailRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.delayFor = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.limit = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        if self.delayFor != 0 {
            my_size += ::protobuf::rt::value_size(3, self.delayFor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        if self.delayFor != 0 {
            os.write_uint32(3, self.delayFor)?;
        }
        if self.limit != 0 {
            os.write_uint32(4, self.limit)?;
        }
        if let Some(ref v) = self.start.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TailRequest {
        TailRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &TailRequest| { &m.query },
                |m: &mut TailRequest| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "delayFor",
                |m: &TailRequest| { &m.delayFor },
                |m: &mut TailRequest| { &mut m.delayFor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "limit",
                |m: &TailRequest| { &m.limit },
                |m: &mut TailRequest| { &mut m.limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "start",
                |m: &TailRequest| { &m.start },
                |m: &mut TailRequest| { &mut m.start },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TailRequest>(
                "TailRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TailRequest {
        static instance: ::protobuf::rt::LazyV2<TailRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TailRequest::new)
    }
}

impl ::protobuf::Clear for TailRequest {
    fn clear(&mut self) {
        self.query.clear();
        self.delayFor = 0;
        self.limit = 0;
        self.start.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TailRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TailRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TailResponse {
    // message fields
    pub stream: ::protobuf::SingularPtrField<StreamAdapter>,
    pub droppedStreams: ::protobuf::RepeatedField<DroppedStream>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TailResponse {
    fn default() -> &'a TailResponse {
        <TailResponse as ::protobuf::Message>::default_instance()
    }
}

impl TailResponse {
    pub fn new() -> TailResponse {
        ::std::default::Default::default()
    }

    // .logproto.StreamAdapter stream = 1;


    pub fn get_stream(&self) -> &StreamAdapter {
        self.stream.as_ref().unwrap_or_else(|| <StreamAdapter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stream(&mut self) {
        self.stream.clear();
    }

    pub fn has_stream(&self) -> bool {
        self.stream.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream(&mut self, v: StreamAdapter) {
        self.stream = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream(&mut self) -> &mut StreamAdapter {
        if self.stream.is_none() {
            self.stream.set_default();
        }
        self.stream.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream(&mut self) -> StreamAdapter {
        self.stream.take().unwrap_or_else(|| StreamAdapter::new())
    }

    // repeated .logproto.DroppedStream droppedStreams = 2;


    pub fn get_droppedStreams(&self) -> &[DroppedStream] {
        &self.droppedStreams
    }
    pub fn clear_droppedStreams(&mut self) {
        self.droppedStreams.clear();
    }

    // Param is passed by value, moved
    pub fn set_droppedStreams(&mut self, v: ::protobuf::RepeatedField<DroppedStream>) {
        self.droppedStreams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_droppedStreams(&mut self) -> &mut ::protobuf::RepeatedField<DroppedStream> {
        &mut self.droppedStreams
    }

    // Take field
    pub fn take_droppedStreams(&mut self) -> ::protobuf::RepeatedField<DroppedStream> {
        ::std::mem::replace(&mut self.droppedStreams, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TailResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.stream {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.droppedStreams {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stream)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.droppedStreams)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stream.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.droppedStreams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stream.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.droppedStreams {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TailResponse {
        TailResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StreamAdapter>>(
                "stream",
                |m: &TailResponse| { &m.stream },
                |m: &mut TailResponse| { &mut m.stream },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DroppedStream>>(
                "droppedStreams",
                |m: &TailResponse| { &m.droppedStreams },
                |m: &mut TailResponse| { &mut m.droppedStreams },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TailResponse>(
                "TailResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TailResponse {
        static instance: ::protobuf::rt::LazyV2<TailResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TailResponse::new)
    }
}

impl ::protobuf::Clear for TailResponse {
    fn clear(&mut self) {
        self.stream.clear();
        self.droppedStreams.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TailResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TailResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SeriesRequest {
    // message fields
    pub start: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub groups: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SeriesRequest {
    fn default() -> &'a SeriesRequest {
        <SeriesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SeriesRequest {
    pub fn new() -> SeriesRequest {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp start = 1;


    pub fn get_start(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start.is_none() {
            self.start.set_default();
        }
        self.start.as_mut().unwrap()
    }

    // Take field
    pub fn take_start(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end = 2;


    pub fn get_end(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end(&mut self) {
        self.end.clear();
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end.is_none() {
            self.end.set_default();
        }
        self.end.as_mut().unwrap()
    }

    // Take field
    pub fn take_end(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // repeated string groups = 3;


    pub fn get_groups(&self) -> &[::std::string::String] {
        &self.groups
    }
    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groups(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.groups
    }

    // Take field
    pub fn take_groups(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.groups, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SeriesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.groups)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.groups {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.start.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.groups {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SeriesRequest {
        SeriesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "start",
                |m: &SeriesRequest| { &m.start },
                |m: &mut SeriesRequest| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "end",
                |m: &SeriesRequest| { &m.end },
                |m: &mut SeriesRequest| { &mut m.end },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "groups",
                |m: &SeriesRequest| { &m.groups },
                |m: &mut SeriesRequest| { &mut m.groups },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SeriesRequest>(
                "SeriesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SeriesRequest {
        static instance: ::protobuf::rt::LazyV2<SeriesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SeriesRequest::new)
    }
}

impl ::protobuf::Clear for SeriesRequest {
    fn clear(&mut self) {
        self.start.clear();
        self.end.clear();
        self.groups.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SeriesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeriesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SeriesResponse {
    // message fields
    pub series: ::protobuf::RepeatedField<SeriesIdentifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SeriesResponse {
    fn default() -> &'a SeriesResponse {
        <SeriesResponse as ::protobuf::Message>::default_instance()
    }
}

impl SeriesResponse {
    pub fn new() -> SeriesResponse {
        ::std::default::Default::default()
    }

    // repeated .logproto.SeriesIdentifier series = 1;


    pub fn get_series(&self) -> &[SeriesIdentifier] {
        &self.series
    }
    pub fn clear_series(&mut self) {
        self.series.clear();
    }

    // Param is passed by value, moved
    pub fn set_series(&mut self, v: ::protobuf::RepeatedField<SeriesIdentifier>) {
        self.series = v;
    }

    // Mutable pointer to the field.
    pub fn mut_series(&mut self) -> &mut ::protobuf::RepeatedField<SeriesIdentifier> {
        &mut self.series
    }

    // Take field
    pub fn take_series(&mut self) -> ::protobuf::RepeatedField<SeriesIdentifier> {
        ::std::mem::replace(&mut self.series, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SeriesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.series {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.series)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.series {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.series {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SeriesResponse {
        SeriesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SeriesIdentifier>>(
                "series",
                |m: &SeriesResponse| { &m.series },
                |m: &mut SeriesResponse| { &mut m.series },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SeriesResponse>(
                "SeriesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SeriesResponse {
        static instance: ::protobuf::rt::LazyV2<SeriesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SeriesResponse::new)
    }
}

impl ::protobuf::Clear for SeriesResponse {
    fn clear(&mut self) {
        self.series.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SeriesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeriesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SeriesIdentifier {
    // message fields
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SeriesIdentifier {
    fn default() -> &'a SeriesIdentifier {
        <SeriesIdentifier as ::protobuf::Message>::default_instance()
    }
}

impl SeriesIdentifier {
    pub fn new() -> SeriesIdentifier {
        ::std::default::Default::default()
    }

    // repeated .logproto.SeriesIdentifier.LabelsEntry labels = 1;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for SeriesIdentifier {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.labels);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.labels, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SeriesIdentifier {
        SeriesIdentifier::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &SeriesIdentifier| { &m.labels },
                |m: &mut SeriesIdentifier| { &mut m.labels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SeriesIdentifier>(
                "SeriesIdentifier",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SeriesIdentifier {
        static instance: ::protobuf::rt::LazyV2<SeriesIdentifier> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SeriesIdentifier::new)
    }
}

impl ::protobuf::Clear for SeriesIdentifier {
    fn clear(&mut self) {
        self.labels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SeriesIdentifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeriesIdentifier {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DroppedStream {
    // message fields
    pub from: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub to: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub labels: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DroppedStream {
    fn default() -> &'a DroppedStream {
        <DroppedStream as ::protobuf::Message>::default_instance()
    }
}

impl DroppedStream {
    pub fn new() -> DroppedStream {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp from = 1;


    pub fn get_from(&self) -> &::protobuf::well_known_types::Timestamp {
        self.from.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    pub fn has_from(&self) -> bool {
        self.from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.from = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.from.is_none() {
            self.from.set_default();
        }
        self.from.as_mut().unwrap()
    }

    // Take field
    pub fn take_from(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.from.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp to = 2;


    pub fn get_to(&self) -> &::protobuf::well_known_types::Timestamp {
        self.to.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    pub fn has_to(&self) -> bool {
        self.to.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.to = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.to.is_none() {
            self.to.set_default();
        }
        self.to.as_mut().unwrap()
    }

    // Take field
    pub fn take_to(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.to.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string labels = 3;


    pub fn get_labels(&self) -> &str {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::string::String) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels(&mut self) -> &mut ::std::string::String {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.labels, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DroppedStream {
    fn is_initialized(&self) -> bool {
        for v in &self.from {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.to {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.to)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.from.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.to.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.labels.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.labels);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.from.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.to.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.labels.is_empty() {
            os.write_string(3, &self.labels)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DroppedStream {
        DroppedStream::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "from",
                |m: &DroppedStream| { &m.from },
                |m: &mut DroppedStream| { &mut m.from },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "to",
                |m: &DroppedStream| { &m.to },
                |m: &mut DroppedStream| { &mut m.to },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &DroppedStream| { &m.labels },
                |m: &mut DroppedStream| { &mut m.labels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DroppedStream>(
                "DroppedStream",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DroppedStream {
        static instance: ::protobuf::rt::LazyV2<DroppedStream> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DroppedStream::new)
    }
}

impl ::protobuf::Clear for DroppedStream {
    fn clear(&mut self) {
        self.from.clear();
        self.to.clear();
        self.labels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DroppedStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DroppedStream {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeSeriesChunk {
    // message fields
    pub from_ingester_id: ::std::string::String,
    pub user_id: ::std::string::String,
    pub labels: ::protobuf::RepeatedField<LabelPair>,
    pub chunks: ::protobuf::RepeatedField<Chunk>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeSeriesChunk {
    fn default() -> &'a TimeSeriesChunk {
        <TimeSeriesChunk as ::protobuf::Message>::default_instance()
    }
}

impl TimeSeriesChunk {
    pub fn new() -> TimeSeriesChunk {
        ::std::default::Default::default()
    }

    // string from_ingester_id = 1;


    pub fn get_from_ingester_id(&self) -> &str {
        &self.from_ingester_id
    }
    pub fn clear_from_ingester_id(&mut self) {
        self.from_ingester_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_from_ingester_id(&mut self, v: ::std::string::String) {
        self.from_ingester_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_ingester_id(&mut self) -> &mut ::std::string::String {
        &mut self.from_ingester_id
    }

    // Take field
    pub fn take_from_ingester_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.from_ingester_id, ::std::string::String::new())
    }

    // string user_id = 2;


    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    // repeated .logproto.LabelPair labels = 3;


    pub fn get_labels(&self) -> &[LabelPair] {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::protobuf::RepeatedField<LabelPair>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::protobuf::RepeatedField<LabelPair> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::protobuf::RepeatedField<LabelPair> {
        ::std::mem::replace(&mut self.labels, ::protobuf::RepeatedField::new())
    }

    // repeated .logproto.Chunk chunks = 4;


    pub fn get_chunks(&self) -> &[Chunk] {
        &self.chunks
    }
    pub fn clear_chunks(&mut self) {
        self.chunks.clear();
    }

    // Param is passed by value, moved
    pub fn set_chunks(&mut self, v: ::protobuf::RepeatedField<Chunk>) {
        self.chunks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chunks(&mut self) -> &mut ::protobuf::RepeatedField<Chunk> {
        &mut self.chunks
    }

    // Take field
    pub fn take_chunks(&mut self) -> ::protobuf::RepeatedField<Chunk> {
        ::std::mem::replace(&mut self.chunks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TimeSeriesChunk {
    fn is_initialized(&self) -> bool {
        for v in &self.labels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.chunks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.from_ingester_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.labels)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chunks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from_ingester_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.from_ingester_id);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user_id);
        }
        for value in &self.labels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.chunks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.from_ingester_id.is_empty() {
            os.write_string(1, &self.from_ingester_id)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(2, &self.user_id)?;
        }
        for v in &self.labels {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.chunks {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeSeriesChunk {
        TimeSeriesChunk::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "from_ingester_id",
                |m: &TimeSeriesChunk| { &m.from_ingester_id },
                |m: &mut TimeSeriesChunk| { &mut m.from_ingester_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_id",
                |m: &TimeSeriesChunk| { &m.user_id },
                |m: &mut TimeSeriesChunk| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelPair>>(
                "labels",
                |m: &TimeSeriesChunk| { &m.labels },
                |m: &mut TimeSeriesChunk| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Chunk>>(
                "chunks",
                |m: &TimeSeriesChunk| { &m.chunks },
                |m: &mut TimeSeriesChunk| { &mut m.chunks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimeSeriesChunk>(
                "TimeSeriesChunk",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimeSeriesChunk {
        static instance: ::protobuf::rt::LazyV2<TimeSeriesChunk> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimeSeriesChunk::new)
    }
}

impl ::protobuf::Clear for TimeSeriesChunk {
    fn clear(&mut self) {
        self.from_ingester_id.clear();
        self.user_id.clear();
        self.labels.clear();
        self.chunks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeSeriesChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeSeriesChunk {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LabelPair {
    // message fields
    pub name: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LabelPair {
    fn default() -> &'a LabelPair {
        <LabelPair as ::protobuf::Message>::default_instance()
    }
}

impl LabelPair {
    pub fn new() -> LabelPair {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LabelPair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LabelPair {
        LabelPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &LabelPair| { &m.name },
                |m: &mut LabelPair| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &LabelPair| { &m.value },
                |m: &mut LabelPair| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LabelPair>(
                "LabelPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LabelPair {
        static instance: ::protobuf::rt::LazyV2<LabelPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LabelPair::new)
    }
}

impl ::protobuf::Clear for LabelPair {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LabelPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Chunk {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Chunk {
    fn default() -> &'a Chunk {
        <Chunk as ::protobuf::Message>::default_instance()
    }
}

impl Chunk {
    pub fn new() -> Chunk {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Chunk {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Chunk {
        Chunk::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &Chunk| { &m.data },
                |m: &mut Chunk| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Chunk>(
                "Chunk",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Chunk {
        static instance: ::protobuf::rt::LazyV2<Chunk> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Chunk::new)
    }
}

impl ::protobuf::Clear for Chunk {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Chunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Chunk {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferChunksResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferChunksResponse {
    fn default() -> &'a TransferChunksResponse {
        <TransferChunksResponse as ::protobuf::Message>::default_instance()
    }
}

impl TransferChunksResponse {
    pub fn new() -> TransferChunksResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TransferChunksResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferChunksResponse {
        TransferChunksResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransferChunksResponse>(
                "TransferChunksResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransferChunksResponse {
        static instance: ::protobuf::rt::LazyV2<TransferChunksResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransferChunksResponse::new)
    }
}

impl ::protobuf::Clear for TransferChunksResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferChunksResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferChunksResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TailersCountRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TailersCountRequest {
    fn default() -> &'a TailersCountRequest {
        <TailersCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl TailersCountRequest {
    pub fn new() -> TailersCountRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TailersCountRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TailersCountRequest {
        TailersCountRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TailersCountRequest>(
                "TailersCountRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TailersCountRequest {
        static instance: ::protobuf::rt::LazyV2<TailersCountRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TailersCountRequest::new)
    }
}

impl ::protobuf::Clear for TailersCountRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TailersCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TailersCountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TailersCountResponse {
    // message fields
    pub count: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TailersCountResponse {
    fn default() -> &'a TailersCountResponse {
        <TailersCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl TailersCountResponse {
    pub fn new() -> TailersCountResponse {
        ::std::default::Default::default()
    }

    // uint32 count = 1;


    pub fn get_count(&self) -> u32 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = v;
    }
}

impl ::protobuf::Message for TailersCountResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.count != 0 {
            os.write_uint32(1, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TailersCountResponse {
        TailersCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count",
                |m: &TailersCountResponse| { &m.count },
                |m: &mut TailersCountResponse| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TailersCountResponse>(
                "TailersCountResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TailersCountResponse {
        static instance: ::protobuf::rt::LazyV2<TailersCountResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TailersCountResponse::new)
    }
}

impl ::protobuf::Clear for TailersCountResponse {
    fn clear(&mut self) {
        self.count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TailersCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TailersCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetChunkIDsRequest {
    // message fields
    pub matchers: ::std::string::String,
    pub start: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetChunkIDsRequest {
    fn default() -> &'a GetChunkIDsRequest {
        <GetChunkIDsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetChunkIDsRequest {
    pub fn new() -> GetChunkIDsRequest {
        ::std::default::Default::default()
    }

    // string matchers = 1;


    pub fn get_matchers(&self) -> &str {
        &self.matchers
    }
    pub fn clear_matchers(&mut self) {
        self.matchers.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchers(&mut self, v: ::std::string::String) {
        self.matchers = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchers(&mut self) -> &mut ::std::string::String {
        &mut self.matchers
    }

    // Take field
    pub fn take_matchers(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.matchers, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp start = 2;


    pub fn get_start(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start.is_none() {
            self.start.set_default();
        }
        self.start.as_mut().unwrap()
    }

    // Take field
    pub fn take_start(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end = 3;


    pub fn get_end(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end(&mut self) {
        self.end.clear();
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end.is_none() {
            self.end.set_default();
        }
        self.end.as_mut().unwrap()
    }

    // Take field
    pub fn take_end(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for GetChunkIDsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.matchers)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.matchers.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.matchers);
        }
        if let Some(ref v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.matchers.is_empty() {
            os.write_string(1, &self.matchers)?;
        }
        if let Some(ref v) = self.start.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetChunkIDsRequest {
        GetChunkIDsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "matchers",
                |m: &GetChunkIDsRequest| { &m.matchers },
                |m: &mut GetChunkIDsRequest| { &mut m.matchers },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "start",
                |m: &GetChunkIDsRequest| { &m.start },
                |m: &mut GetChunkIDsRequest| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "end",
                |m: &GetChunkIDsRequest| { &m.end },
                |m: &mut GetChunkIDsRequest| { &mut m.end },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetChunkIDsRequest>(
                "GetChunkIDsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetChunkIDsRequest {
        static instance: ::protobuf::rt::LazyV2<GetChunkIDsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetChunkIDsRequest::new)
    }
}

impl ::protobuf::Clear for GetChunkIDsRequest {
    fn clear(&mut self) {
        self.matchers.clear();
        self.start.clear();
        self.end.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetChunkIDsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetChunkIDsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetChunkIDsResponse {
    // message fields
    pub chunkIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetChunkIDsResponse {
    fn default() -> &'a GetChunkIDsResponse {
        <GetChunkIDsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetChunkIDsResponse {
    pub fn new() -> GetChunkIDsResponse {
        ::std::default::Default::default()
    }

    // repeated string chunkIDs = 1;


    pub fn get_chunkIDs(&self) -> &[::std::string::String] {
        &self.chunkIDs
    }
    pub fn clear_chunkIDs(&mut self) {
        self.chunkIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_chunkIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.chunkIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chunkIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.chunkIDs
    }

    // Take field
    pub fn take_chunkIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.chunkIDs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetChunkIDsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.chunkIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chunkIDs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chunkIDs {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetChunkIDsResponse {
        GetChunkIDsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chunkIDs",
                |m: &GetChunkIDsResponse| { &m.chunkIDs },
                |m: &mut GetChunkIDsResponse| { &mut m.chunkIDs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetChunkIDsResponse>(
                "GetChunkIDsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetChunkIDsResponse {
        static instance: ::protobuf::rt::LazyV2<GetChunkIDsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetChunkIDsResponse::new)
    }
}

impl ::protobuf::Clear for GetChunkIDsResponse {
    fn clear(&mut self) {
        self.chunkIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetChunkIDsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetChunkIDsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Direction {
    FORWARD = 0,
    BACKWARD = 1,
}

impl ::protobuf::ProtobufEnum for Direction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Direction> {
        match value {
            0 => ::std::option::Option::Some(Direction::FORWARD),
            1 => ::std::option::Option::Some(Direction::BACKWARD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Direction] = &[
            Direction::FORWARD,
            Direction::BACKWARD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Direction>("Direction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Direction {
}

impl ::std::default::Default for Direction {
    fn default() -> Self {
        Direction::FORWARD
    }
}

impl ::protobuf::reflect::ProtobufValue for Direction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0elogproto.proto\x12\x08logproto\x1a\x1fgoogle/protobuf/timestamp.pr\
    oto\x1a#github.com/gogo/protobuf/gogo.proto\"W\n\x0bPushRequest\x12H\n\
    \x07streams\x18\x01\x20\x03(\x0b2\x17.logproto.StreamAdapterR\x07streams\
    B\x15\xea\xde\x1f\x07streams\xda\xde\x1f\x06Stream\"\x0e\n\x0cPushRespon\
    se\"\x9b\x02\n\x0cQueryRequest\x12\x1a\n\x08selector\x18\x01\x20\x01(\tR\
    \x08selector\x12\x14\n\x05limit\x18\x02\x20\x01(\rR\x05limit\x12:\n\x05s\
    tart\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x05startB\x08\
    \xc8\xde\x1f\0\x90\xdf\x1f\x01\x126\n\x03end\x18\x04\x20\x01(\x0b2\x1a.g\
    oogle.protobuf.TimestampR\x03endB\x08\x90\xdf\x1f\x01\xc8\xde\x1f\0\x121\
    \n\tdirection\x18\x05\x20\x01(\x0e2\x13.logproto.DirectionR\tdirection\
    \x12,\n\x06shards\x18\x07\x20\x03(\tR\x06shardsB\x14\xea\xde\x1f\x10shar\
    ds,omitemptyJ\x04\x08\x06\x10\x07\"\xd2\x01\n\x12SampleQueryRequest\x12\
    \x1a\n\x08selector\x18\x01\x20\x01(\tR\x08selector\x12:\n\x05start\x18\
    \x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x05startB\x08\xc8\xde\
    \x1f\0\x90\xdf\x1f\x01\x126\n\x03end\x18\x03\x20\x01(\x0b2\x1a.google.pr\
    otobuf.TimestampR\x03endB\x08\x90\xdf\x1f\x01\xc8\xde\x1f\0\x12,\n\x06sh\
    ards\x18\x04\x20\x03(\tR\x06shardsB\x14\xea\xde\x1f\x10shards,omitempty\
    \"O\n\x13SampleQueryResponse\x128\n\x06series\x18\x01\x20\x03(\x0b2\x10.\
    logproto.SeriesR\x06seriesB\x0e\xda\xde\x1f\x06Series\xc8\xde\x1f\x01\"R\
    \n\rQueryResponse\x12A\n\x07streams\x18\x01\x20\x03(\x0b2\x17.logproto.S\
    treamAdapterR\x07streamsB\x0e\xda\xde\x1f\x06Stream\xc8\xde\x1f\x01\"\
    \xae\x01\n\x0cLabelRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x16\n\x06values\x18\x02\x20\x01(\x08R\x06values\x12:\n\x05start\x18\
    \x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x05startB\x08\xc8\xde\
    \x1f\x01\x90\xdf\x1f\x01\x126\n\x03end\x18\x04\x20\x01(\x0b2\x1a.google.\
    protobuf.TimestampR\x03endB\x08\xc8\xde\x1f\x01\x90\xdf\x1f\x01\"'\n\rLa\
    belResponse\x12\x16\n\x06values\x18\x01\x20\x03(\tR\x06values\"v\n\rStre\
    amAdapter\x12\"\n\x06labels\x18\x01\x20\x01(\tR\x06labelsB\n\xea\xde\x1f\
    \x06labels\x12A\n\x07entries\x18\x02\x20\x03(\x0b2\x16.logproto.EntryAda\
    pterR\x07entriesB\x0f\xc8\xde\x1f\0\xea\xde\x1f\x07entries\"v\n\x0cEntry\
    Adapter\x12H\n\ttimestamp\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.Time\
    stampR\ttimestampB\x0e\xc8\xde\x1f\0\x90\xdf\x1f\x01\xea\xde\x1f\x02ts\
    \x12\x1c\n\x04line\x18\x02\x20\x01(\tR\x04lineB\x08\xea\xde\x1f\x04line\
    \"m\n\x06Sample\x12$\n\ttimestamp\x18\x01\x20\x01(\x03R\ttimestampB\x06\
    \xea\xde\x1f\x02ts\x12\x1f\n\x05value\x18\x02\x20\x01(\x01R\x05valueB\t\
    \xea\xde\x1f\x05value\x12\x1c\n\x04hash\x18\x03\x20\x01(\x04R\x04hashB\
    \x08\xea\xde\x1f\x04hash\"i\n\x06Series\x12\"\n\x06labels\x18\x01\x20\
    \x01(\tR\x06labelsB\n\xea\xde\x1f\x06labels\x12;\n\x07samples\x18\x02\
    \x20\x03(\x0b2\x10.logproto.SampleR\x07samplesB\x0f\xea\xde\x1f\x07sampl\
    es\xc8\xde\x1f\0\"\x97\x01\n\x0bTailRequest\x12\x14\n\x05query\x18\x01\
    \x20\x01(\tR\x05query\x12\x1a\n\x08delayFor\x18\x03\x20\x01(\rR\x08delay\
    For\x12\x14\n\x05limit\x18\x04\x20\x01(\rR\x05limit\x12:\n\x05start\x18\
    \x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x05startB\x08\x90\xdf\
    \x1f\x01\xc8\xde\x1f\0J\x04\x08\x02\x10\x03\"\x8c\x01\n\x0cTailResponse\
    \x12;\n\x06stream\x18\x01\x20\x01(\x0b2\x17.logproto.StreamAdapterR\x06s\
    treamB\n\xda\xde\x1f\x06Stream\x12?\n\x0edroppedStreams\x18\x02\x20\x03(\
    \x0b2\x17.logproto.DroppedStreamR\x0edroppedStreams\"\x9b\x01\n\rSeriesR\
    equest\x12:\n\x05start\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.Timesta\
    mpR\x05startB\x08\x90\xdf\x1f\x01\xc8\xde\x1f\0\x126\n\x03end\x18\x02\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x03endB\x08\xc8\xde\x1f\0\
    \x90\xdf\x1f\x01\x12\x16\n\x06groups\x18\x03\x20\x03(\tR\x06groups\"J\n\
    \x0eSeriesResponse\x128\n\x06series\x18\x01\x20\x03(\x0b2\x1a.logproto.S\
    eriesIdentifierR\x06seriesB\x04\xc8\xde\x1f\0\"\x8d\x01\n\x10SeriesIdent\
    ifier\x12>\n\x06labels\x18\x01\x20\x03(\x0b2&.logproto.SeriesIdentifier.\
    LabelsEntryR\x06labels\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\"\x97\x01\n\rDroppedStream\x128\n\x04from\x18\x01\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x04fromB\x08\x90\xdf\x1f\x01\xc8\xde\x1f\
    \0\x124\n\x02to\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x02\
    toB\x08\xc8\xde\x1f\0\x90\xdf\x1f\x01\x12\x16\n\x06labels\x18\x03\x20\
    \x01(\tR\x06labels\"\xaa\x01\n\x0fTimeSeriesChunk\x12(\n\x10from_ingeste\
    r_id\x18\x01\x20\x01(\tR\x0efromIngesterId\x12\x17\n\x07user_id\x18\x02\
    \x20\x01(\tR\x06userId\x12+\n\x06labels\x18\x03\x20\x03(\x0b2\x13.logpro\
    to.LabelPairR\x06labels\x12'\n\x06chunks\x18\x04\x20\x03(\x0b2\x0f.logpr\
    oto.ChunkR\x06chunks\"5\n\tLabelPair\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\x1b\n\x05C\
    hunk\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\"\x18\n\x16Transfer\
    ChunksResponse\"\x15\n\x13TailersCountRequest\",\n\x14TailersCountRespon\
    se\x12\x14\n\x05count\x18\x01\x20\x01(\rR\x05count\"\xa4\x01\n\x12GetChu\
    nkIDsRequest\x12\x1a\n\x08matchers\x18\x01\x20\x01(\tR\x08matchers\x12:\
    \n\x05start\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x05star\
    tB\x08\x90\xdf\x1f\x01\xc8\xde\x1f\0\x126\n\x03end\x18\x03\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x03endB\x08\xc8\xde\x1f\0\x90\xdf\x1f\
    \x01\"1\n\x13GetChunkIDsResponse\x12\x1a\n\x08chunkIDs\x18\x01\x20\x03(\
    \tR\x08chunkIDs*&\n\tDirection\x12\x0b\n\x07FORWARD\x10\0\x12\x0c\n\x08B\
    ACKWARD\x10\x012A\n\x06Pusher\x127\n\x04Push\x12\x15.logproto.PushReques\
    t\x1a\x16.logproto.PushResponse\"\02\xec\x03\n\x07Querier\x12<\n\x05Quer\
    y\x12\x16.logproto.QueryRequest\x1a\x17.logproto.QueryResponse\"\00\x01\
    \x12N\n\x0bQuerySample\x12\x1c.logproto.SampleQueryRequest\x1a\x1d.logpr\
    oto.SampleQueryResponse\"\00\x01\x12:\n\x05Label\x12\x16.logproto.LabelR\
    equest\x1a\x17.logproto.LabelResponse\"\0\x129\n\x04Tail\x12\x15.logprot\
    o.TailRequest\x1a\x16.logproto.TailResponse\"\00\x01\x12=\n\x06Series\
    \x12\x17.logproto.SeriesRequest\x1a\x18.logproto.SeriesResponse\"\0\x12O\
    \n\x0cTailersCount\x12\x1d.logproto.TailersCountRequest\x1a\x1e.logproto\
    .TailersCountResponse\"\0\x12L\n\x0bGetChunkIDs\x12\x1c.logproto.GetChun\
    kIDsRequest\x1a\x1d.logproto.GetChunkIDsResponse\"\02]\n\x08Ingester\x12\
    Q\n\x0eTransferChunks\x12\x19.logproto.TimeSeriesChunk\x1a\x20.logproto.\
    TransferChunksResponse\"\0(\x01J\xf4.\n\x07\x12\x05\0\0\xa4\x01\x01\n\
    \x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0\x11\n\t\n\
    \x02\x03\0\x12\x03\x05\0)\n\t\n\x02\x03\x01\x12\x03\x06\0-\n\n\n\x02\x06\
    \0\x12\x04\x08\0\n\x01\n\n\n\x03\x06\0\x01\x12\x03\x08\x08\x0e\n\x0b\n\
    \x04\x06\0\x02\0\x12\x03\t\x021\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\t\
    \x06\n\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\t\x0b\x16\n\x0c\n\x05\x06\0\
    \x02\0\x03\x12\x03\t!-\n\n\n\x02\x06\x01\x12\x04\x0c\0\x14\x01\n\n\n\x03\
    \x06\x01\x01\x12\x03\x0c\x08\x0f\n\x0b\n\x04\x06\x01\x02\0\x12\x03\r\x02\
    ;\n\x0c\n\x05\x06\x01\x02\0\x01\x12\x03\r\x06\x0b\n\x0c\n\x05\x06\x01\
    \x02\0\x02\x12\x03\r\x0c\x18\n\x0c\n\x05\x06\x01\x02\0\x06\x12\x03\r#)\n\
    \x0c\n\x05\x06\x01\x02\0\x03\x12\x03\r*7\n\x0b\n\x04\x06\x01\x02\x01\x12\
    \x03\x0e\x02M\n\x0c\n\x05\x06\x01\x02\x01\x01\x12\x03\x0e\x06\x11\n\x0c\
    \n\x05\x06\x01\x02\x01\x02\x12\x03\x0e\x12$\n\x0c\n\x05\x06\x01\x02\x01\
    \x06\x12\x03\x0e/5\n\x0c\n\x05\x06\x01\x02\x01\x03\x12\x03\x0e6I\n\x0b\n\
    \x04\x06\x01\x02\x02\x12\x03\x0f\x024\n\x0c\n\x05\x06\x01\x02\x02\x01\
    \x12\x03\x0f\x06\x0b\n\x0c\n\x05\x06\x01\x02\x02\x02\x12\x03\x0f\x0c\x18\
    \n\x0c\n\x05\x06\x01\x02\x02\x03\x12\x03\x0f#0\n\x0b\n\x04\x06\x01\x02\
    \x03\x12\x03\x10\x028\n\x0c\n\x05\x06\x01\x02\x03\x01\x12\x03\x10\x06\n\
    \n\x0c\n\x05\x06\x01\x02\x03\x02\x12\x03\x10\x0b\x16\n\x0c\n\x05\x06\x01\
    \x02\x03\x06\x12\x03\x10!'\n\x0c\n\x05\x06\x01\x02\x03\x03\x12\x03\x10(4\
    \n\x0b\n\x04\x06\x01\x02\x04\x12\x03\x11\x027\n\x0c\n\x05\x06\x01\x02\
    \x04\x01\x12\x03\x11\x06\x0c\n\x0c\n\x05\x06\x01\x02\x04\x02\x12\x03\x11\
    \r\x1a\n\x0c\n\x05\x06\x01\x02\x04\x03\x12\x03\x11%3\n\x0b\n\x04\x06\x01\
    \x02\x05\x12\x03\x12\x02I\n\x0c\n\x05\x06\x01\x02\x05\x01\x12\x03\x12\
    \x06\x12\n\x0c\n\x05\x06\x01\x02\x05\x02\x12\x03\x12\x13&\n\x0c\n\x05\
    \x06\x01\x02\x05\x03\x12\x03\x121E\n\x0b\n\x04\x06\x01\x02\x06\x12\x03\
    \x13\x02F\n\x0c\n\x05\x06\x01\x02\x06\x01\x12\x03\x13\x06\x11\n\x0c\n\
    \x05\x06\x01\x02\x06\x02\x12\x03\x13\x12$\n\x0c\n\x05\x06\x01\x02\x06\
    \x03\x12\x03\x13/B\n\n\n\x02\x06\x02\x12\x04\x16\0\x18\x01\n\n\n\x03\x06\
    \x02\x01\x12\x03\x16\x08\x10\n\x0b\n\x04\x06\x02\x02\0\x12\x03\x17\x02P\
    \n\x0c\n\x05\x06\x02\x02\0\x01\x12\x03\x17\x06\x14\n\x0c\n\x05\x06\x02\
    \x02\0\x05\x12\x03\x17\x15\x1b\n\x0c\n\x05\x06\x02\x02\0\x02\x12\x03\x17\
    \x1c+\n\x0c\n\x05\x06\x02\x02\0\x03\x12\x03\x176L\n\n\n\x02\x04\0\x12\
    \x04\x1a\0\x1c\x01\n\n\n\x03\x04\0\x01\x12\x03\x1a\x08\x13\n\x0b\n\x04\
    \x04\0\x02\0\x12\x03\x1b\x02j\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x1b\
    \x02\n\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x1b\x0b\x18\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x03\x1b\x19\x20\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x1b#$\
    \n\x0c\n\x05\x04\0\x02\0\x08\x12\x03\x1b%i\n\x0f\n\x08\x04\0\x02\0\x08\
    \xed\xfb\x03\x12\x03\x1b&E\n\x0f\n\x08\x04\0\x02\0\x08\xeb\xfb\x03\x12\
    \x03\x1bGh\n\n\n\x02\x04\x01\x12\x04\x1e\0\x1f\x01\n\n\n\x03\x04\x01\x01\
    \x12\x03\x1e\x08\x14\n\n\n\x02\x04\x02\x12\x04!\0)\x01\n\n\n\x03\x04\x02\
    \x01\x12\x03!\x08\x14\n\x0b\n\x04\x04\x02\x02\0\x12\x03\"\x02\x16\n\x0c\
    \n\x05\x04\x02\x02\0\x05\x12\x03\"\x02\x08\n\x0c\n\x05\x04\x02\x02\0\x01\
    \x12\x03\"\t\x11\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\"\x14\x15\n\x0b\n\
    \x04\x04\x02\x02\x01\x12\x03#\x02\x13\n\x0c\n\x05\x04\x02\x02\x01\x05\
    \x12\x03#\x02\x08\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03#\t\x0e\n\x0c\n\
    \x05\x04\x02\x02\x01\x03\x12\x03#\x11\x12\n\x0b\n\x04\x04\x02\x02\x02\
    \x12\x03$\x02a\n\x0c\n\x05\x04\x02\x02\x02\x06\x12\x03$\x02\x1b\n\x0c\n\
    \x05\x04\x02\x02\x02\x01\x12\x03$\x1c!\n\x0c\n\x05\x04\x02\x02\x02\x03\
    \x12\x03$$%\n\x0c\n\x05\x04\x02\x02\x02\x08\x12\x03$&`\n\x0f\n\x08\x04\
    \x02\x02\x02\x08\xf2\xfb\x03\x12\x03$'A\n\x0f\n\x08\x04\x02\x02\x02\x08\
    \xe9\xfb\x03\x12\x03$C_\n\x0b\n\x04\x04\x02\x02\x03\x12\x03%\x02_\n\x0c\
    \n\x05\x04\x02\x02\x03\x06\x12\x03%\x02\x1b\n\x0c\n\x05\x04\x02\x02\x03\
    \x01\x12\x03%\x1c\x1f\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03%\"#\n\x0c\
    \n\x05\x04\x02\x02\x03\x08\x12\x03%$^\n\x0f\n\x08\x04\x02\x02\x03\x08\
    \xf2\xfb\x03\x12\x03%%?\n\x0f\n\x08\x04\x02\x02\x03\x08\xe9\xfb\x03\x12\
    \x03%A]\n\x0b\n\x04\x04\x02\x02\x04\x12\x03&\x02\x1a\n\x0c\n\x05\x04\x02\
    \x02\x04\x06\x12\x03&\x02\x0b\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03&\
    \x0c\x15\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03&\x18\x19\n\n\n\x03\x04\
    \x02\t\x12\x03'\x02\r\n\x0b\n\x04\x04\x02\t\0\x12\x03'\x0b\x0c\n\x0c\n\
    \x05\x04\x02\t\0\x01\x12\x03'\x0b\x0c\n\x0c\n\x05\x04\x02\t\0\x02\x12\
    \x03'\x0b\x0c\n\x0b\n\x04\x04\x02\x02\x05\x12\x03(\x02H\n\x0c\n\x05\x04\
    \x02\x02\x05\x04\x12\x03(\x02\n\n\x0c\n\x05\x04\x02\x02\x05\x05\x12\x03(\
    \x0b\x11\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03(\x12\x18\n\x0c\n\x05\
    \x04\x02\x02\x05\x03\x12\x03(\x1b\x1c\n\x0c\n\x05\x04\x02\x02\x05\x08\
    \x12\x03(\x1dG\n\x0f\n\x08\x04\x02\x02\x05\x08\xed\xfb\x03\x12\x03(\x1eF\
    \n\n\n\x02\x04\x03\x12\x04+\00\x01\n\n\n\x03\x04\x03\x01\x12\x03+\x08\
    \x1a\n\x0b\n\x04\x04\x03\x02\0\x12\x03,\x02\x16\n\x0c\n\x05\x04\x03\x02\
    \0\x05\x12\x03,\x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03,\t\x11\n\
    \x0c\n\x05\x04\x03\x02\0\x03\x12\x03,\x14\x15\n\x0b\n\x04\x04\x03\x02\
    \x01\x12\x03-\x02a\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x03-\x02\x1b\n\
    \x0c\n\x05\x04\x03\x02\x01\x01\x12\x03-\x1c!\n\x0c\n\x05\x04\x03\x02\x01\
    \x03\x12\x03-$%\n\x0c\n\x05\x04\x03\x02\x01\x08\x12\x03-&`\n\x0f\n\x08\
    \x04\x03\x02\x01\x08\xf2\xfb\x03\x12\x03-'A\n\x0f\n\x08\x04\x03\x02\x01\
    \x08\xe9\xfb\x03\x12\x03-C_\n\x0b\n\x04\x04\x03\x02\x02\x12\x03.\x02_\n\
    \x0c\n\x05\x04\x03\x02\x02\x06\x12\x03.\x02\x1b\n\x0c\n\x05\x04\x03\x02\
    \x02\x01\x12\x03.\x1c\x1f\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03.\"#\n\
    \x0c\n\x05\x04\x03\x02\x02\x08\x12\x03.$^\n\x0f\n\x08\x04\x03\x02\x02\
    \x08\xf2\xfb\x03\x12\x03.%?\n\x0f\n\x08\x04\x03\x02\x02\x08\xe9\xfb\x03\
    \x12\x03.A]\n\x0b\n\x04\x04\x03\x02\x03\x12\x03/\x02H\n\x0c\n\x05\x04\
    \x03\x02\x03\x04\x12\x03/\x02\n\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03/\
    \x0b\x11\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03/\x12\x18\n\x0c\n\x05\
    \x04\x03\x02\x03\x03\x12\x03/\x1b\x1c\n\x0c\n\x05\x04\x03\x02\x03\x08\
    \x12\x03/\x1dG\n\x0f\n\x08\x04\x03\x02\x03\x08\xed\xfb\x03\x12\x03/\x1eF\
    \n\n\n\x02\x04\x04\x12\x042\04\x01\n\n\n\x03\x04\x04\x01\x12\x032\x08\
    \x1b\n\x0b\n\x04\x04\x04\x02\0\x12\x033\x02^\n\x0c\n\x05\x04\x04\x02\0\
    \x04\x12\x033\x02\n\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x033\x0b\x11\n\x0c\
    \n\x05\x04\x04\x02\0\x01\x12\x033\x12\x18\n\x0c\n\x05\x04\x04\x02\0\x03\
    \x12\x033\x1b\x1c\n\x0c\n\x05\x04\x04\x02\0\x08\x12\x033\x1d]\n\x0f\n\
    \x08\x04\x04\x02\0\x08\xeb\xfb\x03\x12\x033\x1e?\n\x0f\n\x08\x04\x04\x02\
    \0\x08\xe9\xfb\x03\x12\x033A\\\n\n\n\x02\x05\0\x12\x046\09\x01\n\n\n\x03\
    \x05\0\x01\x12\x036\x05\x0e\n\x0b\n\x04\x05\0\x02\0\x12\x037\x02\x0e\n\
    \x0c\n\x05\x05\0\x02\0\x01\x12\x037\x02\t\n\x0c\n\x05\x05\0\x02\0\x02\
    \x12\x037\x0c\r\n\x0b\n\x04\x05\0\x02\x01\x12\x038\x02\x0f\n\x0c\n\x05\
    \x05\0\x02\x01\x01\x12\x038\x02\n\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x038\
    \r\x0e\n\n\n\x02\x04\x05\x12\x04;\0=\x01\n\n\n\x03\x04\x05\x01\x12\x03;\
    \x08\x15\n\x0b\n\x04\x04\x05\x02\0\x12\x03<\x02f\n\x0c\n\x05\x04\x05\x02\
    \0\x04\x12\x03<\x02\n\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03<\x0b\x18\n\
    \x0c\n\x05\x04\x05\x02\0\x01\x12\x03<\x19\x20\n\x0c\n\x05\x04\x05\x02\0\
    \x03\x12\x03<#$\n\x0c\n\x05\x04\x05\x02\0\x08\x12\x03<%e\n\x0f\n\x08\x04\
    \x05\x02\0\x08\xeb\xfb\x03\x12\x03<&G\n\x0f\n\x08\x04\x05\x02\0\x08\xe9\
    \xfb\x03\x12\x03<Id\n\n\n\x02\x04\x06\x12\x04?\0D\x01\n\n\n\x03\x04\x06\
    \x01\x12\x03?\x08\x14\n\x0b\n\x04\x04\x06\x02\0\x12\x03@\x02\x12\n\x0c\n\
    \x05\x04\x06\x02\0\x05\x12\x03@\x02\x08\n\x0c\n\x05\x04\x06\x02\0\x01\
    \x12\x03@\t\r\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03@\x10\x11\nH\n\x04\
    \x04\x06\x02\x01\x12\x03A\x02\x12\";\x20True\x20to\x20fetch\x20label\x20\
    values,\x20false\x20for\x20fetch\x20labels\x20names.\n\n\x0c\n\x05\x04\
    \x06\x02\x01\x05\x12\x03A\x02\x06\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\
    \x03A\x07\r\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03A\x10\x11\n\x0b\n\x04\
    \x04\x06\x02\x02\x12\x03B\x02`\n\x0c\n\x05\x04\x06\x02\x02\x06\x12\x03B\
    \x02\x1b\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03B\x1c!\n\x0c\n\x05\x04\
    \x06\x02\x02\x03\x12\x03B$%\n\x0c\n\x05\x04\x06\x02\x02\x08\x12\x03B&_\n\
    \x0f\n\x08\x04\x06\x02\x02\x08\xf2\xfb\x03\x12\x03B'A\n\x0f\n\x08\x04\
    \x06\x02\x02\x08\xe9\xfb\x03\x12\x03BC^\n\x0b\n\x04\x04\x06\x02\x03\x12\
    \x03C\x02^\n\x0c\n\x05\x04\x06\x02\x03\x06\x12\x03C\x02\x1b\n\x0c\n\x05\
    \x04\x06\x02\x03\x01\x12\x03C\x1c\x1f\n\x0c\n\x05\x04\x06\x02\x03\x03\
    \x12\x03C\"#\n\x0c\n\x05\x04\x06\x02\x03\x08\x12\x03C$]\n\x0f\n\x08\x04\
    \x06\x02\x03\x08\xf2\xfb\x03\x12\x03C%?\n\x0f\n\x08\x04\x06\x02\x03\x08\
    \xe9\xfb\x03\x12\x03CA\\\n\n\n\x02\x04\x07\x12\x04F\0H\x01\n\n\n\x03\x04\
    \x07\x01\x12\x03F\x08\x15\n\x0b\n\x04\x04\x07\x02\0\x12\x03G\x02\x1d\n\
    \x0c\n\x05\x04\x07\x02\0\x04\x12\x03G\x02\n\n\x0c\n\x05\x04\x07\x02\0\
    \x05\x12\x03G\x0b\x11\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03G\x12\x18\n\
    \x0c\n\x05\x04\x07\x02\0\x03\x12\x03G\x1b\x1c\n\n\n\x02\x04\x08\x12\x04J\
    \0M\x01\n\n\n\x03\x04\x08\x01\x12\x03J\x08\x15\n\x0b\n\x04\x04\x08\x02\0\
    \x12\x03K\x025\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03K\x02\x08\n\x0c\n\
    \x05\x04\x08\x02\0\x01\x12\x03K\t\x0f\n\x0c\n\x05\x04\x08\x02\0\x03\x12\
    \x03K\x12\x13\n\x0c\n\x05\x04\x08\x02\0\x08\x12\x03K\x144\n\x0f\n\x08\
    \x04\x08\x02\0\x08\xed\xfb\x03\x12\x03K\x153\n\x0b\n\x04\x04\x08\x02\x01\
    \x12\x03L\x02d\n\x0c\n\x05\x04\x08\x02\x01\x04\x12\x03L\x02\n\n\x0c\n\
    \x05\x04\x08\x02\x01\x06\x12\x03L\x0b\x17\n\x0c\n\x05\x04\x08\x02\x01\
    \x01\x12\x03L\x18\x1f\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03L\"#\n\x0c\
    \n\x05\x04\x08\x02\x01\x08\x12\x03L$c\n\x0f\n\x08\x04\x08\x02\x01\x08\
    \xe9\xfb\x03\x12\x03L%A\n\x0f\n\x08\x04\x08\x02\x01\x08\xed\xfb\x03\x12\
    \x03LCb\n\n\n\x02\x04\t\x12\x04O\0R\x01\n\n\n\x03\x04\t\x01\x12\x03O\x08\
    \x14\n\x0c\n\x04\x04\t\x02\0\x12\x04P\x02\x81\x01\n\x0c\n\x05\x04\t\x02\
    \0\x06\x12\x03P\x02\x1b\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03P\x1c%\n\x0c\
    \n\x05\x04\t\x02\0\x03\x12\x03P()\n\r\n\x05\x04\t\x02\0\x08\x12\x04P*\
    \x80\x01\n\x0f\n\x08\x04\t\x02\0\x08\xf2\xfb\x03\x12\x03P+E\n\x0f\n\x08\
    \x04\t\x02\0\x08\xe9\xfb\x03\x12\x03PGc\n\x0f\n\x08\x04\t\x02\0\x08\xed\
    \xfb\x03\x12\x03Pe\x7f\n\x0b\n\x04\x04\t\x02\x01\x12\x03Q\x021\n\x0c\n\
    \x05\x04\t\x02\x01\x05\x12\x03Q\x02\x08\n\x0c\n\x05\x04\t\x02\x01\x01\
    \x12\x03Q\t\r\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03Q\x10\x11\n\x0c\n\x05\
    \x04\t\x02\x01\x08\x12\x03Q\x120\n\x0f\n\x08\x04\t\x02\x01\x08\xed\xfb\
    \x03\x12\x03Q\x13/\n\n\n\x02\x04\n\x12\x04T\0X\x01\n\n\n\x03\x04\n\x01\
    \x12\x03T\x08\x0e\n\x0b\n\x04\x04\n\x02\0\x12\x03U\x023\n\x0c\n\x05\x04\
    \n\x02\0\x05\x12\x03U\x02\x07\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03U\x08\
    \x11\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03U\x14\x15\n\x0c\n\x05\x04\n\x02\
    \0\x08\x12\x03U\x162\n\x0f\n\x08\x04\n\x02\0\x08\xed\xfb\x03\x12\x03U\
    \x171\n\x0b\n\x04\x04\n\x02\x01\x12\x03V\x023\n\x0c\n\x05\x04\n\x02\x01\
    \x05\x12\x03V\x02\x08\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03V\t\x0e\n\x0c\
    \n\x05\x04\n\x02\x01\x03\x12\x03V\x11\x12\n\x0c\n\x05\x04\n\x02\x01\x08\
    \x12\x03V\x132\n\x0f\n\x08\x04\n\x02\x01\x08\xed\xfb\x03\x12\x03V\x141\n\
    \x0b\n\x04\x04\n\x02\x02\x12\x03W\x021\n\x0c\n\x05\x04\n\x02\x02\x05\x12\
    \x03W\x02\x08\n\x0c\n\x05\x04\n\x02\x02\x01\x12\x03W\t\r\n\x0c\n\x05\x04\
    \n\x02\x02\x03\x12\x03W\x10\x11\n\x0c\n\x05\x04\n\x02\x02\x08\x12\x03W\
    \x120\n\x0f\n\x08\x04\n\x02\x02\x08\xed\xfb\x03\x12\x03W\x13/\n\n\n\x02\
    \x04\x0b\x12\x04Z\0]\x01\n\n\n\x03\x04\x0b\x01\x12\x03Z\x08\x0e\n\x0b\n\
    \x04\x04\x0b\x02\0\x12\x03[\x025\n\x0c\n\x05\x04\x0b\x02\0\x05\x12\x03[\
    \x02\x08\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03[\t\x0f\n\x0c\n\x05\x04\
    \x0b\x02\0\x03\x12\x03[\x12\x13\n\x0c\n\x05\x04\x0b\x02\0\x08\x12\x03[\
    \x144\n\x0f\n\x08\x04\x0b\x02\0\x08\xed\xfb\x03\x12\x03[\x153\n\x0b\n\
    \x04\x04\x0b\x02\x01\x12\x03\\\x02^\n\x0c\n\x05\x04\x0b\x02\x01\x04\x12\
    \x03\\\x02\n\n\x0c\n\x05\x04\x0b\x02\x01\x06\x12\x03\\\x0b\x11\n\x0c\n\
    \x05\x04\x0b\x02\x01\x01\x12\x03\\\x12\x19\n\x0c\n\x05\x04\x0b\x02\x01\
    \x03\x12\x03\\\x1c\x1d\n\x0c\n\x05\x04\x0b\x02\x01\x08\x12\x03\\\x1e]\n\
    \x0f\n\x08\x04\x0b\x02\x01\x08\xe9\xfb\x03\x12\x03\\\x1f;\n\x0f\n\x08\
    \x04\x0b\x02\x01\x08\xed\xfb\x03\x12\x03\\=\\\n\n\n\x02\x04\x0c\x12\x04_\
    \0e\x01\n\n\n\x03\x04\x0c\x01\x12\x03_\x08\x13\n\x0b\n\x04\x04\x0c\x02\0\
    \x12\x03`\x02\x13\n\x0c\n\x05\x04\x0c\x02\0\x05\x12\x03`\x02\x08\n\x0c\n\
    \x05\x04\x0c\x02\0\x01\x12\x03`\t\x0e\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\
    \x03`\x11\x12\n\n\n\x03\x04\x0c\t\x12\x03a\x02\r\n\x0b\n\x04\x04\x0c\t\0\
    \x12\x03a\x0b\x0c\n\x0c\n\x05\x04\x0c\t\0\x01\x12\x03a\x0b\x0c\n\x0c\n\
    \x05\x04\x0c\t\0\x02\x12\x03a\x0b\x0c\n\x0b\n\x04\x04\x0c\x02\x01\x12\
    \x03b\x02\x16\n\x0c\n\x05\x04\x0c\x02\x01\x05\x12\x03b\x02\x08\n\x0c\n\
    \x05\x04\x0c\x02\x01\x01\x12\x03b\t\x11\n\x0c\n\x05\x04\x0c\x02\x01\x03\
    \x12\x03b\x14\x15\n\x0b\n\x04\x04\x0c\x02\x02\x12\x03c\x02\x13\n\x0c\n\
    \x05\x04\x0c\x02\x02\x05\x12\x03c\x02\x08\n\x0c\n\x05\x04\x0c\x02\x02\
    \x01\x12\x03c\t\x0e\n\x0c\n\x05\x04\x0c\x02\x02\x03\x12\x03c\x11\x12\n\
    \x0b\n\x04\x04\x0c\x02\x03\x12\x03d\x02a\n\x0c\n\x05\x04\x0c\x02\x03\x06\
    \x12\x03d\x02\x1b\n\x0c\n\x05\x04\x0c\x02\x03\x01\x12\x03d\x1c!\n\x0c\n\
    \x05\x04\x0c\x02\x03\x03\x12\x03d$%\n\x0c\n\x05\x04\x0c\x02\x03\x08\x12\
    \x03d&`\n\x0f\n\x08\x04\x0c\x02\x03\x08\xf2\xfb\x03\x12\x03d'A\n\x0f\n\
    \x08\x04\x0c\x02\x03\x08\xe9\xfb\x03\x12\x03dC_\n\n\n\x02\x04\r\x12\x04g\
    \0j\x01\n\n\n\x03\x04\r\x01\x12\x03g\x08\x14\n\x0b\n\x04\x04\r\x02\0\x12\
    \x03h\x02?\n\x0c\n\x05\x04\r\x02\0\x06\x12\x03h\x02\x0f\n\x0c\n\x05\x04\
    \r\x02\0\x01\x12\x03h\x10\x16\n\x0c\n\x05\x04\r\x02\0\x03\x12\x03h\x19\
    \x1a\n\x0c\n\x05\x04\r\x02\0\x08\x12\x03h\x1b>\n\x0f\n\x08\x04\r\x02\0\
    \x08\xeb\xfb\x03\x12\x03h\x1c=\n\x0b\n\x04\x04\r\x02\x01\x12\x03i\x02,\n\
    \x0c\n\x05\x04\r\x02\x01\x04\x12\x03i\x02\n\n\x0c\n\x05\x04\r\x02\x01\
    \x06\x12\x03i\x0b\x18\n\x0c\n\x05\x04\r\x02\x01\x01\x12\x03i\x19'\n\x0c\
    \n\x05\x04\r\x02\x01\x03\x12\x03i*+\n\n\n\x02\x04\x0e\x12\x04l\0p\x01\n\
    \n\n\x03\x04\x0e\x01\x12\x03l\x08\x15\n\x0b\n\x04\x04\x0e\x02\0\x12\x03m\
    \x02a\n\x0c\n\x05\x04\x0e\x02\0\x06\x12\x03m\x02\x1b\n\x0c\n\x05\x04\x0e\
    \x02\0\x01\x12\x03m\x1c!\n\x0c\n\x05\x04\x0e\x02\0\x03\x12\x03m$%\n\x0c\
    \n\x05\x04\x0e\x02\0\x08\x12\x03m&`\n\x0f\n\x08\x04\x0e\x02\0\x08\xf2\
    \xfb\x03\x12\x03m'A\n\x0f\n\x08\x04\x0e\x02\0\x08\xe9\xfb\x03\x12\x03mC_\
    \n\x0b\n\x04\x04\x0e\x02\x01\x12\x03n\x02_\n\x0c\n\x05\x04\x0e\x02\x01\
    \x06\x12\x03n\x02\x1b\n\x0c\n\x05\x04\x0e\x02\x01\x01\x12\x03n\x1c\x1f\n\
    \x0c\n\x05\x04\x0e\x02\x01\x03\x12\x03n\"#\n\x0c\n\x05\x04\x0e\x02\x01\
    \x08\x12\x03n$^\n\x0f\n\x08\x04\x0e\x02\x01\x08\xf2\xfb\x03\x12\x03n%?\n\
    \x0f\n\x08\x04\x0e\x02\x01\x08\xe9\xfb\x03\x12\x03nA]\n\x0b\n\x04\x04\
    \x0e\x02\x02\x12\x03o\x02\x1d\n\x0c\n\x05\x04\x0e\x02\x02\x04\x12\x03o\
    \x02\n\n\x0c\n\x05\x04\x0e\x02\x02\x05\x12\x03o\x0b\x11\n\x0c\n\x05\x04\
    \x0e\x02\x02\x01\x12\x03o\x12\x18\n\x0c\n\x05\x04\x0e\x02\x02\x03\x12\
    \x03o\x1b\x1c\n\n\n\x02\x04\x0f\x12\x04r\0t\x01\n\n\n\x03\x04\x0f\x01\
    \x12\x03r\x08\x16\n\x0b\n\x04\x04\x0f\x02\0\x12\x03s\x02F\n\x0c\n\x05\
    \x04\x0f\x02\0\x04\x12\x03s\x02\n\n\x0c\n\x05\x04\x0f\x02\0\x06\x12\x03s\
    \x0b\x1b\n\x0c\n\x05\x04\x0f\x02\0\x01\x12\x03s\x1c\"\n\x0c\n\x05\x04\
    \x0f\x02\0\x03\x12\x03s%&\n\x0c\n\x05\x04\x0f\x02\0\x08\x12\x03s'E\n\x0f\
    \n\x08\x04\x0f\x02\0\x08\xe9\xfb\x03\x12\x03s(D\n\n\n\x02\x04\x10\x12\
    \x04v\0x\x01\n\n\n\x03\x04\x10\x01\x12\x03v\x08\x18\n\x0b\n\x04\x04\x10\
    \x02\0\x12\x03w\x02\x20\n\x0c\n\x05\x04\x10\x02\0\x06\x12\x03w\x02\x14\n\
    \x0c\n\x05\x04\x10\x02\0\x01\x12\x03w\x15\x1b\n\x0c\n\x05\x04\x10\x02\0\
    \x03\x12\x03w\x1e\x1f\n\n\n\x02\x04\x11\x12\x04z\0~\x01\n\n\n\x03\x04\
    \x11\x01\x12\x03z\x08\x15\n\x0b\n\x04\x04\x11\x02\0\x12\x03{\x02`\n\x0c\
    \n\x05\x04\x11\x02\0\x06\x12\x03{\x02\x1b\n\x0c\n\x05\x04\x11\x02\0\x01\
    \x12\x03{\x1c\x20\n\x0c\n\x05\x04\x11\x02\0\x03\x12\x03{#$\n\x0c\n\x05\
    \x04\x11\x02\0\x08\x12\x03{%_\n\x0f\n\x08\x04\x11\x02\0\x08\xf2\xfb\x03\
    \x12\x03{&@\n\x0f\n\x08\x04\x11\x02\0\x08\xe9\xfb\x03\x12\x03{B^\n\x0b\n\
    \x04\x04\x11\x02\x01\x12\x03|\x02^\n\x0c\n\x05\x04\x11\x02\x01\x06\x12\
    \x03|\x02\x1b\n\x0c\n\x05\x04\x11\x02\x01\x01\x12\x03|\x1c\x1e\n\x0c\n\
    \x05\x04\x11\x02\x01\x03\x12\x03|!\"\n\x0c\n\x05\x04\x11\x02\x01\x08\x12\
    \x03|#]\n\x0f\n\x08\x04\x11\x02\x01\x08\xf2\xfb\x03\x12\x03|$>\n\x0f\n\
    \x08\x04\x11\x02\x01\x08\xe9\xfb\x03\x12\x03|@\\\n\x0b\n\x04\x04\x11\x02\
    \x02\x12\x03}\x02\x14\n\x0c\n\x05\x04\x11\x02\x02\x05\x12\x03}\x02\x08\n\
    \x0c\n\x05\x04\x11\x02\x02\x01\x12\x03}\t\x0f\n\x0c\n\x05\x04\x11\x02\
    \x02\x03\x12\x03}\x12\x13\n\x0c\n\x02\x04\x12\x12\x06\x80\x01\0\x85\x01\
    \x01\n\x0b\n\x03\x04\x12\x01\x12\x04\x80\x01\x08\x17\n\x0c\n\x04\x04\x12\
    \x02\0\x12\x04\x81\x01\x02\x1e\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\x81\
    \x01\x02\x08\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\x81\x01\t\x19\n\r\n\x05\
    \x04\x12\x02\0\x03\x12\x04\x81\x01\x1c\x1d\n\x0c\n\x04\x04\x12\x02\x01\
    \x12\x04\x82\x01\x02\x15\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\x82\x01\
    \x02\x08\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\x82\x01\t\x10\n\r\n\x05\
    \x04\x12\x02\x01\x03\x12\x04\x82\x01\x13\x14\n\x0c\n\x04\x04\x12\x02\x02\
    \x12\x04\x83\x01\x02\x20\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\x83\x01\
    \x02\n\n\r\n\x05\x04\x12\x02\x02\x06\x12\x04\x83\x01\x0b\x14\n\r\n\x05\
    \x04\x12\x02\x02\x01\x12\x04\x83\x01\x15\x1b\n\r\n\x05\x04\x12\x02\x02\
    \x03\x12\x04\x83\x01\x1e\x1f\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\x84\x01\
    \x02\x1c\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04\x84\x01\x02\n\n\r\n\x05\
    \x04\x12\x02\x03\x06\x12\x04\x84\x01\x0b\x10\n\r\n\x05\x04\x12\x02\x03\
    \x01\x12\x04\x84\x01\x11\x17\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\x84\
    \x01\x1a\x1b\n\x0c\n\x02\x04\x13\x12\x06\x87\x01\0\x8a\x01\x01\n\x0b\n\
    \x03\x04\x13\x01\x12\x04\x87\x01\x08\x11\n\x0c\n\x04\x04\x13\x02\0\x12\
    \x04\x88\x01\x02\x12\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\x88\x01\x02\x08\
    \n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x88\x01\t\r\n\r\n\x05\x04\x13\x02\0\
    \x03\x12\x04\x88\x01\x10\x11\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\x89\x01\
    \x02\x13\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\x89\x01\x02\x08\n\r\n\x05\
    \x04\x13\x02\x01\x01\x12\x04\x89\x01\t\x0e\n\r\n\x05\x04\x13\x02\x01\x03\
    \x12\x04\x89\x01\x11\x12\n\x0c\n\x02\x04\x14\x12\x06\x8c\x01\0\x8e\x01\
    \x01\n\x0b\n\x03\x04\x14\x01\x12\x04\x8c\x01\x08\r\n\x0c\n\x04\x04\x14\
    \x02\0\x12\x04\x8d\x01\x02\x11\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\x8d\
    \x01\x02\x07\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\x8d\x01\x08\x0c\n\r\n\
    \x05\x04\x14\x02\0\x03\x12\x04\x8d\x01\x0f\x10\n\x0c\n\x02\x04\x15\x12\
    \x06\x90\x01\0\x92\x01\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\x90\x01\x08\
    \x1e\n\x0c\n\x02\x04\x16\x12\x06\x94\x01\0\x96\x01\x01\n\x0b\n\x03\x04\
    \x16\x01\x12\x04\x94\x01\x08\x1b\n\x0c\n\x02\x04\x17\x12\x06\x98\x01\0\
    \x9a\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\x98\x01\x08\x1c\n\x0c\n\x04\
    \x04\x17\x02\0\x12\x04\x99\x01\x02\x13\n\r\n\x05\x04\x17\x02\0\x05\x12\
    \x04\x99\x01\x02\x08\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\x99\x01\t\x0e\n\
    \r\n\x05\x04\x17\x02\0\x03\x12\x04\x99\x01\x11\x12\n\x0c\n\x02\x04\x18\
    \x12\x06\x9c\x01\0\xa0\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\x9c\x01\
    \x08\x1a\n\x0c\n\x04\x04\x18\x02\0\x12\x04\x9d\x01\x02\x16\n\r\n\x05\x04\
    \x18\x02\0\x05\x12\x04\x9d\x01\x02\x08\n\r\n\x05\x04\x18\x02\0\x01\x12\
    \x04\x9d\x01\t\x11\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\x9d\x01\x14\x15\n\
    \x0c\n\x04\x04\x18\x02\x01\x12\x04\x9e\x01\x02a\n\r\n\x05\x04\x18\x02\
    \x01\x06\x12\x04\x9e\x01\x02\x1b\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\
    \x9e\x01\x1c!\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\x9e\x01$%\n\r\n\x05\
    \x04\x18\x02\x01\x08\x12\x04\x9e\x01&`\n\x10\n\x08\x04\x18\x02\x01\x08\
    \xf2\xfb\x03\x12\x04\x9e\x01'A\n\x10\n\x08\x04\x18\x02\x01\x08\xe9\xfb\
    \x03\x12\x04\x9e\x01C_\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\x9f\x01\x02_\
    \n\r\n\x05\x04\x18\x02\x02\x06\x12\x04\x9f\x01\x02\x1b\n\r\n\x05\x04\x18\
    \x02\x02\x01\x12\x04\x9f\x01\x1c\x1f\n\r\n\x05\x04\x18\x02\x02\x03\x12\
    \x04\x9f\x01\"#\n\r\n\x05\x04\x18\x02\x02\x08\x12\x04\x9f\x01$^\n\x10\n\
    \x08\x04\x18\x02\x02\x08\xf2\xfb\x03\x12\x04\x9f\x01%?\n\x10\n\x08\x04\
    \x18\x02\x02\x08\xe9\xfb\x03\x12\x04\x9f\x01A]\n\x0c\n\x02\x04\x19\x12\
    \x06\xa2\x01\0\xa4\x01\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xa2\x01\x08\
    \x1b\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xa3\x01\x02\x1f\n\r\n\x05\x04\x19\
    \x02\0\x04\x12\x04\xa3\x01\x02\n\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xa3\
    \x01\x0b\x11\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xa3\x01\x12\x1a\n\r\n\
    \x05\x04\x19\x02\0\x03\x12\x04\xa3\x01\x1d\x1eb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
